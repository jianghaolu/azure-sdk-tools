// ----------------------------------------------------------------------------------
//
// Copyright Microsoft Corporation
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------------------------------------------------------------

namespace Microsoft.WindowsAzure.Commands.ServiceManagement.Extensions
{
    // to invoke script from within cmdlet 
    using Microsoft.WindowsAzure.Management.Compute.Models;
    using Model.PersistentVMModel;
    using Properties;
    using System;
    using System.Linq;
    using System.Management.Automation;
    using System.Xml;
    using Utilities.Common;
    using Microsoft.WindowsAzure.Commands.Storage.Model.ResourceModel;
    using WindowsAzure.Storage;
    using WindowsAzure.Storage.Auth;

    /// <summary>
    /// Set Windows Azure Service Antimalware Extension.
    /// </summary>
    [Cmdlet(VerbsCommon.Set, "AzureServiceAntimalwareExtension", DefaultParameterSetName = "SetExtension"), OutputType(typeof(ManagementOperationContext))]
    public class SetAzureServiceAntimalwareExtensionCommand : BaseAzureServiceAntimalwareExtensionCmdlet
    {
        [Parameter(Position = 0, ValueFromPipelineByPropertyName = true, Mandatory = true, ParameterSetName = "SetExtension", HelpMessage = "Cloud Service Name")]
        [Parameter(Position = 0, ValueFromPipelineByPropertyName = true, Mandatory = true, ParameterSetName = "SetExtensionUsingThumbprint", HelpMessage = "Cloud Service Name")]
        [ValidateNotNullOrEmpty]
        public override string ServiceName { get; set; }

        [Parameter(Position = 1, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = "SetExtension", HelpMessage = "Production (default) or Staging.")]
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = "SetExtensionUsingThumbprint", HelpMessage = "Production (default) or Staging.")]
        [ValidateSet(DeploymentSlotType.Production, DeploymentSlotType.Staging, IgnoreCase = true)]
        public override string Slot { get; set; }

        [Parameter(Position = 2, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = "SetExtension", HelpMessage = "Default All Roles, or specify ones for Named Roles.")]
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = "SetExtensionUsingThumbprint", HelpMessage = "Default All Roles, or specify ones for Named Roles.")]
        [ValidateNotNullOrEmpty]
        public override string[] Role { get; set; }

        [Parameter(Position = 3, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = "SetExtension", HelpMessage = "The Antimalware Configuration cannot be null or empty and must include at a minimum <AntimalwareConfig><AntimalwareEnabled>true</AntimalwareEnabled></AntimalwareConfig> to enable Microsoft Antimalware.")]
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = "SetExtensionUsingThumbprint", HelpMessage = "The Antimalware Configuration cannot be null or empty and must include at a minimum <AntimalwareConfig><AntimalwareEnabled>true</AntimalwareEnabled></AntimalwareConfig> to enable Microsoft Antimalware.")]
        [ValidateNotNullOrEmpty]
        public override XmlDocument AntimalwareConfiguration { get; set; }

        [Parameter(Position = 4, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = "SetExtension", HelpMessage = "Monitoring (ON = antimalware events logged to storage, OFF = no event logging)")]
        [Parameter(Position = 4, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = "SetExtensionUsingThumbprint", HelpMessage = "Monitoring (ON = antimalware events logged to storage, OFF = no event logging)")]
        [ValidateSet("ON", "OFF", IgnoreCase = true)]
        public string Monitoring { get; set; }

        [Parameter(Position = 5, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = "SetExtension", HelpMessage = "Microsoft Antimalware Monitoring Storage Context")]
        [Parameter(Position = 5, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = "SetExtensionUsingThumbprint", HelpMessage = "Microsoft Antimalware Monitoring Storage Context")]
        [ValidateNotNullOrEmpty]
        public override AzureStorageContext StorageContext { get; set; }

        private bool isAntimalwareEnabled = false;   // do not enable antimalware unless specified in configuration or parameters
        private enum MonitoringActionType { Enable, Disable, NoActionRequested } ;
        private MonitoringActionType monitoringAction = MonitoringActionType.NoActionRequested; // default to no action requested until identified in config or parameter

        private string monitoringStorageAccountName; // for retrieving storage account name when specified in config file

        protected override void ValidateParameters()
        {
            base.ValidateParameters();
            ValidateService();
            ValidateDeployment();
            ValidateRoles();
            ValidateThumbprint(true);
            ValidateConfiguration();
        }

        private void AddNewAntimalwareMonitoringConfig()
        {
            // install diagnostics provider with a new antimalware event monitoring config
            InitializeDiagnosticsSettings();
            ExtensionConfigurationInput diagExtConfigInput = new ExtensionConfigurationInput
            {
                ProviderNameSpace = ProviderNamespace,
                Type = ExtensionName,
                CertificateThumbprint = CertificateThumbprint,
                ThumbprintAlgorithm = ThumbprintAlgorithm,
                X509Certificate = X509Certificate,
                PublicConfiguration = PublicConfiguration,
                PrivateConfiguration = PrivateConfiguration,
                Roles = new ExtensionRoleList(Role != null && Role.Any() ? Role.Select(r => new ExtensionRole(r)) : Enumerable.Repeat(new ExtensionRole(), 1))
            };
            AntimalwareMonitoringExtensionConfigurationInput = diagExtConfigInput;
        }

        private void MergeAntimalwareMonitoringIntoExistingConfig(string existingConfigXmlStr)
        {
            // prepare a new xml document to hold the merged config
            XmlDocument mergedConfig = new XmlDocument();
            mergedConfig.LoadXml(existingConfigXmlStr);

            // check if old config already contains a WindowsEventLog section
            string targetNode;
            string mergeXmlStr;
            if (existingConfigXmlStr.Contains(DiagnosticsConfigWindowsEventLogNodeName))
            {
                // inject into the existing windows event log section 
                targetNode = DiagnosticsConfigWindowsEventLogNodeName;
                mergeXmlStr = DiagnosticsDefaultConfigMergeXmlWithExistingEventLogNode;
            }
            else
            {
                // inject a windows event log section with antimalware monitoring into the diagnostics config 
                targetNode = DiagnosticsConfigNodeName;
                mergeXmlStr = DiagnosticsDefaultConfigMergeXmlWithoutExistingEventLogNode;
            }

            // locate the desired target using xpath 
            string diagXPathStr = String.Format("//*[local-name()='{0}' and namespace-uri()='{1}']", targetNode, DiagnosticsConfigXmlNamespace);
            XmlNode diagNode = mergedConfig.DocumentElement.SelectSingleNode(diagXPathStr);

            // create an import node and then append to the correct location
            XmlDocument diagnosticsConfigXml = new XmlDocument();
            diagnosticsConfigXml.LoadXml(mergeXmlStr);

            XmlNode importNode = mergedConfig.ImportNode(diagnosticsConfigXml.DocumentElement, true);
            diagNode.AppendChild(importNode);

            // Note : Currently any pre-existing user of the diagnostics configuration will be expected 
            // to follow convention of specifying storage account name in the xml configuration so that 
            // it can be persisted across configuration changes being made by multiple users. 

            // remove any stray xmlns="" attribute from xml string prior to use 
            string mergedConfiguration = mergedConfig.OuterXml.Replace(@"xmlns=""""", "");

            // now reinstall the extension with the new configuration
            InitializeDiagnosticsSettings();
            ExtensionConfigurationInput diagExtConfigInput = new ExtensionConfigurationInput
            {
                ProviderNameSpace = ProviderNamespace,
                Type = ExtensionName,
                CertificateThumbprint = CertificateThumbprint,
                ThumbprintAlgorithm = ThumbprintAlgorithm,
                X509Certificate = X509Certificate,
                PublicConfiguration = mergedConfiguration,
                PrivateConfiguration = PrivateConfiguration,
                Roles = new ExtensionRoleList(Role != null && Role.Any() ? Role.Select(r => new ExtensionRole(r)) : Enumerable.Repeat(new ExtensionRole(), 1))
            };

            // set up for reinstall with new configuration
            AntimalwareMonitoringExtensionConfigurationInput = diagExtConfigInput;
        }
            
        protected void EnableMonitoring()
        {
            // retrieve any pre-existing diagnostics extension
            var ext = GetDiagnosticsExtension();

            if ( (ext == null) && 
                 ((monitoringAction==MonitoringActionType.Disable) || (monitoringAction == MonitoringActionType.NoActionRequested)) )
            {
                // if there was no pre-existing diagnostics extension there is 
                // nothing to do in either of these two cases so exit early 

                // note the user may not have provided a storage account either
                // so this check is performed prior to storage account validation                
                return;   
            }

            // establish the storage account name to be associated with monitoring
            if (!IsValidStorageContext())
            {
                // no valid storage context exists, try to initialize storage context using config value
                InitializeStorageContext(monitoringStorageAccountName);
            }

            if (!IsValidStorageContext())
            {
                // still unable to associate the storage account name with a valid storage context
                ThrowTerminatingError(new ErrorRecord(
                            new Exception(Resources.ServiceExtensionCannotFindStorageAccountName),
                            string.Empty,
                            ErrorCategory.InvalidData,
                            null));
            }

            if (ext != null)
            {
                // save the current configuration of the diagnostics extension
                // in the event we do not end up needing to modify it but need
                // to persist the config in the final call to change deployment 
                InitializeDiagnosticsSettings();
                AntimalwareMonitoringExtensionConfigurationInput = new ExtensionConfigurationInput
                {
                    ProviderNameSpace = ProviderNamespace,
                    Type = ExtensionName,
                    CertificateThumbprint = CertificateThumbprint,
                    ThumbprintAlgorithm = ThumbprintAlgorithm,
                    X509Certificate = X509Certificate,
                    PublicConfiguration = ext.PublicConfiguration,
                    PrivateConfiguration = PrivateConfiguration,
                    Roles = new ExtensionRoleList(Role != null && Role.Any() ? Role.Select(r => new ExtensionRole(r)) : Enumerable.Repeat(new ExtensionRole(), 1))
                };
            }

            switch (monitoringAction)
            {
                case (MonitoringActionType.Enable) :
                    if (ext == null)
                    {
                        AddNewAntimalwareMonitoringConfig();
                    }
                    else
                    {
                        // extension already exists, check to see if it already contains antimalware data source
                        if (!ext.PublicConfiguration.Contains(DiagnosticsConfigAntimalwareProviderToken))
                        {
                            // antimalware data source is not already in the configuration, merge it 
                            // with existing config (tracking perf counters, other event logs, etc.)
                            MergeAntimalwareMonitoringIntoExistingConfig(ext.PublicConfiguration);
                        }
                    }
                    break;

                case (MonitoringActionType.Disable) :
                    if (ext != null)
                    {
                        RemoveExistingAntimalwareMonitoringConfig();
                    }
                    break;

                case (MonitoringActionType.NoActionRequested) :
                    break;

                default: 
                    break;
            }
        }

        protected override void ValidateConfiguration()
        {
            // read values from xml file if provided
            if (AntimalwareConfiguration != null)
            {
                // check for antimalware enabled 
                XmlNode antimalwareEnabledNode = AntimalwareConfiguration.SelectSingleNode("//AntimalwareConfig/AntimalwareEnabled");
                if ((antimalwareEnabledNode != null) && (antimalwareEnabledNode.InnerText != null))
                {
                    isAntimalwareEnabled = antimalwareEnabledNode.InnerText.ToUpperInvariant().Equals("TRUE");
                }

                // check for monitoring enabled 
                XmlNode monitoringNode = AntimalwareConfiguration.SelectSingleNode("//AntimalwareConfig/Monitoring");
                if (monitoringNode != null)
                {
                    if (monitoringNode.InnerText != null)
                    {
                        switch (monitoringNode.InnerText.ToUpperInvariant())
                        {
                            case "ON": monitoringAction = MonitoringActionType.Enable; break;
                            case "OFF": monitoringAction = MonitoringActionType.Disable; break;
                            default: break;
                        }    
                    }

                    // now remove the monitoring node from the xml document since it 
                    // is not recognized by the schema used by the antimalware extension
                    monitoringNode.ParentNode.RemoveChild(monitoringNode);
                }

                // check for storage account name if present in the config file
                XmlNode storageAccountNameNode = AntimalwareConfiguration.SelectSingleNode("//AntimalwareConfig/StorageAccountName");
                if (storageAccountNameNode != null)
                {
                    if (storageAccountNameNode.InnerText != null)
                    {
                        monitoringStorageAccountName = storageAccountNameNode.InnerText;
                    }
                    // strip this node from the xml prior to passing to antimalware extension
                    storageAccountNameNode.ParentNode.RemoveChild(storageAccountNameNode);
                }
            }

            // process Monitoring parameter if specified (will override any setting in xml config)
            if (Monitoring != null)
            {
                switch (Monitoring.ToUpperInvariant())
                {
                    case "ON": monitoringAction = MonitoringActionType.Enable; break;
                    case "OFF": monitoringAction = MonitoringActionType.Disable; break;
                    default: break;
                }                
            }

            // always error if user has not opted in to enable antimalware 
            if (!isAntimalwareEnabled)
            {
                ThrowTerminatingError(new ErrorRecord(
                            new Exception(Resources.ServiceExtensionCannotFindAntimalwareEnableSetting),
                            string.Empty,
                            ErrorCategory.InvalidData,
                            null));
            }
        }

        public void ExecuteCommand()
        {
            ValidateParameters();

            // set diagnostics extension
            switch (monitoringAction)
            {
                case MonitoringActionType.Enable : EnableMonitoring(); break;
                case MonitoringActionType.Disable : RemoveExistingAntimalwareMonitoringConfig(); break;
                default: break;
            }

            // set antimalware extension 
            InitializeAntimalwareSettings();
            ExtensionConfigurationInput amExtConfigInput = new ExtensionConfigurationInput
            {
                ProviderNameSpace = ProviderNamespace,
                Type = ExtensionName,
                PublicConfiguration = PublicConfiguration,
                PrivateConfiguration = PrivateConfiguration,
                Roles = new ExtensionRoleList(Role != null && Role.Any() ? Role.Select(r => new ExtensionRole(r)) : Enumerable.Repeat(new ExtensionRole(), 1))
            };
            AntimalwareExtensionConfigurationInput = amExtConfigInput;

            ExtensionConfigurationInput[] extConfigInputs = null;
            if (AntimalwareExtensionConfigurationInput != null && AntimalwareMonitoringExtensionConfigurationInput != null)
            {
                extConfigInputs = new ExtensionConfigurationInput[2];
                extConfigInputs[0] = AntimalwareMonitoringExtensionConfigurationInput;
                extConfigInputs[1] = AntimalwareExtensionConfigurationInput;
            }
            else if (AntimalwareExtensionConfigurationInput != null)
            {
                extConfigInputs = new ExtensionConfigurationInput[1];
                extConfigInputs[0] = AntimalwareExtensionConfigurationInput;
            }
            else if (AntimalwareMonitoringExtensionConfigurationInput!=null)
            {
                extConfigInputs = new ExtensionConfigurationInput[1];
                extConfigInputs[0] = AntimalwareMonitoringExtensionConfigurationInput;
            }

            // process any pending deployment changes
            if (extConfigInputs != null)
            {
                ExtensionConfiguration newExtConfig = ExtensionManager.Add(Deployment, extConfigInputs, Slot);
                ChangeDeployment(newExtConfig);
            }
        }

        protected override void OnProcessRecord()
        {
            ExecuteCommand();
        }
    }
}
